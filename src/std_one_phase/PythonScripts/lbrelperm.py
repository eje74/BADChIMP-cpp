import numpy as np
import os
import subprocess
import time
from generate_geometry_mpi import new_run

class relperm:
    """
    Class for handeling the BADChIMP runs to generate the releative permiabilities
    for the saturation paths generated by the level set simulations.
    It is assumed that the data from the ls-simaltions are saved in the numpy 
    format with the file extension `.npy` and that the elements for the solid and 
    fluid fields follows the convention:
        Solid geometry:
          element > 0: solid
        Fluid geometry:
          element > 0: wetting

    Attributes
    ----------
    pathlbroot : str
        Path to the root folder for the BADChIMP code 
    pathinputroot : str
        Path to the root of the LS data. The rest of the
        paths will be specified in `run`.
    maxlim : int, default = 3
        Maximum number of processes to run in parallell.
    keyphrase: str, default = "ITERATION"
        Text used to detect when BADChIMP as read the 
        vtklb files, so that they can be overwritten. 
    numproc : tuple[int], default = (3, 3, 3)
        Number of bins in each spatial direction so that
        `prod(num_proc)` is the maximum number of domains

    Methods
    -------
    run(...)
        Runs BADChIMP on a geometry, given by the LS-data files.
    """
    def __init__(self, 
                 pathlb: str, 
                 pathinput: str,
                 maxlim: int = 3,
                 keyphrase: str = "ITERATION",
                 numproc : tuple[int] = (3, 3, 3),
                 ):
        """
        Parameters
        ----------
        pathlb : str
            Path to the root folder for the BADChIMP code 
        pathinput : str
            Path to the root of the LS data. The rest of the
            paths will be specified in `run`.
        maxlim : int, default = 3
            Maximum number of processes to run in parallell.
        keyphrase: str, default = "ITERATION"
            Text used to detect when BADChIMP as read the 
            vtklb files, so that they can be overwritten. 
        numproc : tuple[int], default = (3, 3, 3)
            Number of bins in each spatial direction so that
            `prod(num_proc)` is the maximum number of domains

        """
        # ======================================================================== Root paths
        # ------------------------------------------------------------------------ badchimp folder
        # `expanduser` inserts for `tilde` in the path 
        self.pathlbroot = os.path.expanduser(pathlb)
        # ------------------------------------------------------------------------ ls data folder
        self.pathinputroot = os.path.expanduser(pathinput) 
        # ======================================================================== Setup runs
        self.maxlim = maxlim
        self.numproc = numproc
        self.keyphrase = keyphrase

    def run(self,
            subdirectories: list[str],
            filestamp: str = "",
            maxiterations: int = 50000,
            writeinterval: int = 500,
            tau: float = 0.8,
            bodyforce_z: float = 1.0e-6
            ) -> None:
        """
        Runs BADChIMP for the geometries defined in the numpy files in the folder
        given in `subdirectories`. 
        Runs the PoreSolid geometry first so that the pore space is known.
        The runs the wetting and non-wetting fluid configurations.
        The data is saved in a csv-file with the extension .dat on the format
        interation, sum moment in x, sum moment in y, sum moment in z.
        The force has only a component in the z-direction os the permeabilities
        are calculated based on the velocity in the z direction.  

        Parameters
        ----------
        subdirectories : list[str]
            list of the folder path from `pathinputroot` to the actual data-files
        filestamp : str, default = ""
            Additional string added to the data file produced by BADChIMP
        maxiterations : int, default = 50_000
            Maximum number of iterations
        writeinterval : int, default = 500
            Number of iterations between file write
        tau : float, default = 0.8
            LB relaxation time
        bodyforce_z : float, default = 1.0e-6
            Body force component in the z-spatial direction
        """
        # ======================================================================== Data folder
        pathinput = self.pathinputroot
        pathinput += r"/".join(subdirectories) + r"/"
        # ======================================================================== File names
        # ------------------------------------------------------------------------ fluid phases
        filenames = [x[:-4] for x in os.listdir(pathinput) if r"CG_NWP" in x]
        # ------------------------------------------------------------------------ Rock data
        filebase = [x[:-4] for x in os.listdir(pathinput) if r"CG_PoreSolid" in x][0]
        # ======================================================================== LS Data
        running_processes = []
        # ------------------------------------------------------------------------ Pore space
        pore = np.load(pathinput + filebase + r".npy")
        # ------------------------------------------------------------------------ generate geometry
        geo = np.ones(pore.shape, dtype=np.int32)
        geo[pore>0] = 0
        nproc, proc = new_run(geo, 
                              self.pathlbroot, 
                              filebase + filestamp, 
                              self.numproc, 
                              self.keyphrase, 
                              maxiterations, 
                              writeinterval, 
                              tau, 
                              bodyforce_z
                              )
        if proc:
            running_processes.append(proc)

        for filebase in filenames:
            while len(running_processes) >= self.maxlim:
                # Take some time between checks
                time.sleep(10)
                for proc in running_processes:
                # If process has terminated
                    if proc.poll() is not None:
                        # Propely halt the process
                        proc.communicate()
                        # Remove it from the list of
                        # running processes
                        running_processes.remove(proc)
                        # Break the for-loop
                        break
                        # We know that the number of running processes
                        # are less then max_lim so we will also exit
                        # the while-loop
            # We add a new process to the running processes
            fluid = np.load(pathinput + filebase +r".npy")
            geo[:] = 1
            # -------------------------------------------------------------------- Wetting phase
            geo[fluid<=0] = 0
            geo[pore>0] = 0
            nproc, proc = new_run(geo, 
                                  self.pathlbroot, 
                                  filebase + filestamp + r"_W",
                                  self.numproc, 
                                  self.keyphrase, 
                                  maxiterations, 
                                  writeinterval, 
                                  tau, 
                                  bodyforce_z
                                  )
            if proc:
                running_processes.append(proc)
            while len(running_processes) >= self.maxlim:
                time.sleep(10)
                for proc in running_processes:
                    if proc.poll() is not None:
                        proc.communicate()
                        running_processes.remove(proc)
                        break
            # -------------------------------------------------------------------- Non-wetting phase
            geo[:] = 1
            geo[fluid>0] = 0
            geo[pore>0] = 0
            nproc, proc = new_run(geo, 
                                  self.pathlbroot, 
                                  filebase + filestamp + r"_NW", 
                                  self.numproc, 
                                  self.keyphrase, 
                                  maxiterations, 
                                  writeinterval, 
                                  tau, 
                                  bodyforce_z
                                  )
            if proc:
                running_processes.append(proc)
        # End the rest of the processes
        while len(running_processes) > 0:
            for proc in running_processes:
                if proc.poll() is not None:
                    proc.communicate()
                    running_processes.remove(proc)


if __name__ == "__main__":
    myruns = relperm(
        r"~/Programs/GitHub/BADChIMP-cpp/",
        r"~/OneDrive/NORCE/CSSR/RelPerm LB LS/",
        maxlim=2,
        numproc=(3, 3, 3)
    )

    datafolder_base = [
        r"Castlegate_Tow20_LVC_Oil",
        r"Sat_control",
        r"Swi_0_65"
        ]

    # ---------------------------------------------------------------------------- Main Imbibition
    datafolder = datafolder_base + [r"MainImbibition_REV1"]
    myruns.run(datafolder)

    # ---------------------------------------------------------------------------- Main Drainage
    datafolder = datafolder_base + [r"MainDrainage_REV2"]
    myruns.run(datafolder)


    # ---------------------------------------------------------------------------- Secondary Drainage
    filestamps = [r"Sw073", r"Sw082"]
    for filestamp in filestamps:
        datafolder = datafolder_base + [r"Drainage_From" + filestamp + r"_REV2"]
        myruns.run(datafolder, filestamp)

    # ---------------------------------------------------------------------------- Secondary Imbibition
    filestamps = [r"Sw073", r"Sw082"]
    for filestamp in filestamps:
        datafolder = datafolder_base + [r"Imbibition_From" + filestamp + r"_REV3"]
        myruns.run(datafolder, filestamp)
